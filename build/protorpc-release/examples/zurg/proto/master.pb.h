// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: master.proto

#ifndef PROTOBUF_master_2eproto__INCLUDED
#define PROTOBUF_master_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "muduo/protorpc2/rpc2.pb.h"
#include "slave.pb.h"
#include <muduo/protorpc2/service.h>
#include <memory>
// @@protoc_insertion_point(includes)

namespace zurg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_master_2eproto();
void protobuf_AssignDesc_master_2eproto();
void protobuf_ShutdownFile_master_2eproto();

class SlaveHeartbeat;
class SlaveHeartbeat_Uname;

// ===================================================================

class SlaveHeartbeat_Uname : public ::google::protobuf::Message {
 public:
  SlaveHeartbeat_Uname();
  virtual ~SlaveHeartbeat_Uname();

  SlaveHeartbeat_Uname(const SlaveHeartbeat_Uname& from);

  inline SlaveHeartbeat_Uname& operator=(const SlaveHeartbeat_Uname& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveHeartbeat_Uname& default_instance();

  void Swap(SlaveHeartbeat_Uname* other);

  // implements Message ----------------------------------------------

  SlaveHeartbeat_Uname* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveHeartbeat_Uname& from);
  void MergeFrom(const SlaveHeartbeat_Uname& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sysname = 1;
  inline bool has_sysname() const;
  inline void clear_sysname();
  static const int kSysnameFieldNumber = 1;
  inline const ::std::string& sysname() const;
  inline void set_sysname(const ::std::string& value);
  inline void set_sysname(const char* value);
  inline void set_sysname(const char* value, size_t size);
  inline ::std::string* mutable_sysname();
  inline ::std::string* release_sysname();
  inline void set_allocated_sysname(::std::string* sysname);

  // required string nodename = 2;
  inline bool has_nodename() const;
  inline void clear_nodename();
  static const int kNodenameFieldNumber = 2;
  inline const ::std::string& nodename() const;
  inline void set_nodename(const ::std::string& value);
  inline void set_nodename(const char* value);
  inline void set_nodename(const char* value, size_t size);
  inline ::std::string* mutable_nodename();
  inline ::std::string* release_nodename();
  inline void set_allocated_nodename(::std::string* nodename);

  // required string release = 3;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 3;
  inline const ::std::string& release() const;
  inline void set_release(const ::std::string& value);
  inline void set_release(const char* value);
  inline void set_release(const char* value, size_t size);
  inline ::std::string* mutable_release();
  inline ::std::string* release_release();
  inline void set_allocated_release(::std::string* release);

  // required string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required string machine = 5;
  inline bool has_machine() const;
  inline void clear_machine();
  static const int kMachineFieldNumber = 5;
  inline const ::std::string& machine() const;
  inline void set_machine(const ::std::string& value);
  inline void set_machine(const char* value);
  inline void set_machine(const char* value, size_t size);
  inline ::std::string* mutable_machine();
  inline ::std::string* release_machine();
  inline void set_allocated_machine(::std::string* machine);

  // required string domainname = 6;
  inline bool has_domainname() const;
  inline void clear_domainname();
  static const int kDomainnameFieldNumber = 6;
  inline const ::std::string& domainname() const;
  inline void set_domainname(const ::std::string& value);
  inline void set_domainname(const char* value);
  inline void set_domainname(const char* value, size_t size);
  inline ::std::string* mutable_domainname();
  inline ::std::string* release_domainname();
  inline void set_allocated_domainname(::std::string* domainname);

  // @@protoc_insertion_point(class_scope:zurg.SlaveHeartbeat.Uname)
 private:
  inline void set_has_sysname();
  inline void clear_has_sysname();
  inline void set_has_nodename();
  inline void clear_has_nodename();
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_machine();
  inline void clear_has_machine();
  inline void set_has_domainname();
  inline void clear_has_domainname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sysname_;
  ::std::string* nodename_;
  ::std::string* release_;
  ::std::string* version_;
  ::std::string* machine_;
  ::std::string* domainname_;
  friend void  protobuf_AddDesc_master_2eproto();
  friend void protobuf_AssignDesc_master_2eproto();
  friend void protobuf_ShutdownFile_master_2eproto();

  void InitAsDefaultInstance();
  static SlaveHeartbeat_Uname* default_instance_;
};
// -------------------------------------------------------------------

class SlaveHeartbeat : public ::google::protobuf::Message {
 public:
  SlaveHeartbeat();
  virtual ~SlaveHeartbeat();

  SlaveHeartbeat(const SlaveHeartbeat& from);

  inline SlaveHeartbeat& operator=(const SlaveHeartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveHeartbeat& default_instance();

  void Swap(SlaveHeartbeat* other);

  // implements Message ----------------------------------------------

  SlaveHeartbeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlaveHeartbeat& from);
  void MergeFrom(const SlaveHeartbeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SlaveHeartbeat_Uname Uname;

  // accessors -------------------------------------------------------

  // required string slave_name = 1;
  inline bool has_slave_name() const;
  inline void clear_slave_name();
  static const int kSlaveNameFieldNumber = 1;
  inline const ::std::string& slave_name() const;
  inline void set_slave_name(const ::std::string& value);
  inline void set_slave_name(const char* value);
  inline void set_slave_name(const char* value, size_t size);
  inline ::std::string* mutable_slave_name();
  inline ::std::string* release_slave_name();
  inline void set_allocated_slave_name(::std::string* slave_name);

  // required int64 send_time_us = 2;
  inline bool has_send_time_us() const;
  inline void clear_send_time_us();
  static const int kSendTimeUsFieldNumber = 2;
  inline ::google::protobuf::int64 send_time_us() const;
  inline void set_send_time_us(::google::protobuf::int64 value);

  // optional string host_name = 20;
  inline bool has_host_name() const;
  inline void clear_host_name();
  static const int kHostNameFieldNumber = 20;
  inline const ::std::string& host_name() const;
  inline void set_host_name(const ::std::string& value);
  inline void set_host_name(const char* value);
  inline void set_host_name(const char* value, size_t size);
  inline ::std::string* mutable_host_name();
  inline ::std::string* release_host_name();
  inline void set_allocated_host_name(::std::string* host_name);

  // optional int32 listen_port = 21;
  inline bool has_listen_port() const;
  inline void clear_listen_port();
  static const int kListenPortFieldNumber = 21;
  inline ::google::protobuf::int32 listen_port() const;
  inline void set_listen_port(::google::protobuf::int32 value);

  // optional int32 slave_pid = 22;
  inline bool has_slave_pid() const;
  inline void clear_slave_pid();
  static const int kSlavePidFieldNumber = 22;
  inline ::google::protobuf::int32 slave_pid() const;
  inline void set_slave_pid(::google::protobuf::int32 value);

  // optional int64 start_time_us = 23;
  inline bool has_start_time_us() const;
  inline void clear_start_time_us();
  static const int kStartTimeUsFieldNumber = 23;
  inline ::google::protobuf::int64 start_time_us() const;
  inline void set_start_time_us(::google::protobuf::int64 value);

  // optional string slave_version = 24;
  inline bool has_slave_version() const;
  inline void clear_slave_version();
  static const int kSlaveVersionFieldNumber = 24;
  inline const ::std::string& slave_version() const;
  inline void set_slave_version(const ::std::string& value);
  inline void set_slave_version(const char* value);
  inline void set_slave_version(const char* value, size_t size);
  inline ::std::string* mutable_slave_version();
  inline ::std::string* release_slave_version();
  inline void set_allocated_slave_version(::std::string* slave_version);

  // repeated string env_vars = 25;
  inline int env_vars_size() const;
  inline void clear_env_vars();
  static const int kEnvVarsFieldNumber = 25;
  inline const ::std::string& env_vars(int index) const;
  inline ::std::string* mutable_env_vars(int index);
  inline void set_env_vars(int index, const ::std::string& value);
  inline void set_env_vars(int index, const char* value);
  inline void set_env_vars(int index, const char* value, size_t size);
  inline ::std::string* add_env_vars();
  inline void add_env_vars(const ::std::string& value);
  inline void add_env_vars(const char* value);
  inline void add_env_vars(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& env_vars() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_env_vars();

  // optional string cpuinfo = 30;
  inline bool has_cpuinfo() const;
  inline void clear_cpuinfo();
  static const int kCpuinfoFieldNumber = 30;
  inline const ::std::string& cpuinfo() const;
  inline void set_cpuinfo(const ::std::string& value);
  inline void set_cpuinfo(const char* value);
  inline void set_cpuinfo(const char* value, size_t size);
  inline ::std::string* mutable_cpuinfo();
  inline ::std::string* release_cpuinfo();
  inline void set_allocated_cpuinfo(::std::string* cpuinfo);

  // optional string version = 31;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 31;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string etc_mtab = 32;
  inline bool has_etc_mtab() const;
  inline void clear_etc_mtab();
  static const int kEtcMtabFieldNumber = 32;
  inline const ::std::string& etc_mtab() const;
  inline void set_etc_mtab(const ::std::string& value);
  inline void set_etc_mtab(const char* value);
  inline void set_etc_mtab(const char* value, size_t size);
  inline ::std::string* mutable_etc_mtab();
  inline ::std::string* release_etc_mtab();
  inline void set_allocated_etc_mtab(::std::string* etc_mtab);

  // optional string sysctl = 33;
  inline bool has_sysctl() const;
  inline void clear_sysctl();
  static const int kSysctlFieldNumber = 33;
  inline const ::std::string& sysctl() const;
  inline void set_sysctl(const ::std::string& value);
  inline void set_sysctl(const char* value);
  inline void set_sysctl(const char* value, size_t size);
  inline ::std::string* mutable_sysctl();
  inline ::std::string* release_sysctl();
  inline void set_allocated_sysctl(::std::string* sysctl);

  // optional .zurg.SlaveHeartbeat.Uname uname = 34;
  inline bool has_uname() const;
  inline void clear_uname();
  static const int kUnameFieldNumber = 34;
  inline const ::zurg::SlaveHeartbeat_Uname& uname() const;
  inline ::zurg::SlaveHeartbeat_Uname* mutable_uname();
  inline ::zurg::SlaveHeartbeat_Uname* release_uname();
  inline void set_allocated_uname(::zurg::SlaveHeartbeat_Uname* uname);

  // optional string meminfo = 40;
  inline bool has_meminfo() const;
  inline void clear_meminfo();
  static const int kMeminfoFieldNumber = 40;
  inline const ::std::string& meminfo() const;
  inline void set_meminfo(const ::std::string& value);
  inline void set_meminfo(const char* value);
  inline void set_meminfo(const char* value, size_t size);
  inline ::std::string* mutable_meminfo();
  inline ::std::string* release_meminfo();
  inline void set_allocated_meminfo(::std::string* meminfo);

  // optional string proc_stat = 41;
  inline bool has_proc_stat() const;
  inline void clear_proc_stat();
  static const int kProcStatFieldNumber = 41;
  inline const ::std::string& proc_stat() const;
  inline void set_proc_stat(const ::std::string& value);
  inline void set_proc_stat(const char* value);
  inline void set_proc_stat(const char* value, size_t size);
  inline ::std::string* mutable_proc_stat();
  inline ::std::string* release_proc_stat();
  inline void set_allocated_proc_stat(::std::string* proc_stat);

  // optional string loadavg = 42;
  inline bool has_loadavg() const;
  inline void clear_loadavg();
  static const int kLoadavgFieldNumber = 42;
  inline const ::std::string& loadavg() const;
  inline void set_loadavg(const ::std::string& value);
  inline void set_loadavg(const char* value);
  inline void set_loadavg(const char* value, size_t size);
  inline ::std::string* mutable_loadavg();
  inline ::std::string* release_loadavg();
  inline void set_allocated_loadavg(::std::string* loadavg);

  // optional string diskstats = 43;
  inline bool has_diskstats() const;
  inline void clear_diskstats();
  static const int kDiskstatsFieldNumber = 43;
  inline const ::std::string& diskstats() const;
  inline void set_diskstats(const ::std::string& value);
  inline void set_diskstats(const char* value);
  inline void set_diskstats(const char* value, size_t size);
  inline ::std::string* mutable_diskstats();
  inline ::std::string* release_diskstats();
  inline void set_allocated_diskstats(::std::string* diskstats);

  // optional string net_dev = 44;
  inline bool has_net_dev() const;
  inline void clear_net_dev();
  static const int kNetDevFieldNumber = 44;
  inline const ::std::string& net_dev() const;
  inline void set_net_dev(const ::std::string& value);
  inline void set_net_dev(const char* value);
  inline void set_net_dev(const char* value, size_t size);
  inline ::std::string* mutable_net_dev();
  inline ::std::string* release_net_dev();
  inline void set_allocated_net_dev(::std::string* net_dev);

  // optional string net_tcp = 45;
  inline bool has_net_tcp() const;
  inline void clear_net_tcp();
  static const int kNetTcpFieldNumber = 45;
  inline const ::std::string& net_tcp() const;
  inline void set_net_tcp(const ::std::string& value);
  inline void set_net_tcp(const char* value);
  inline void set_net_tcp(const char* value, size_t size);
  inline ::std::string* mutable_net_tcp();
  inline ::std::string* release_net_tcp();
  inline void set_allocated_net_tcp(::std::string* net_tcp);

  // repeated .zurg.DiskUsage disk_usage = 50;
  inline int disk_usage_size() const;
  inline void clear_disk_usage();
  static const int kDiskUsageFieldNumber = 50;
  inline const ::zurg::DiskUsage& disk_usage(int index) const;
  inline ::zurg::DiskUsage* mutable_disk_usage(int index);
  inline ::zurg::DiskUsage* add_disk_usage();
  inline const ::google::protobuf::RepeatedPtrField< ::zurg::DiskUsage >&
      disk_usage() const;
  inline ::google::protobuf::RepeatedPtrField< ::zurg::DiskUsage >*
      mutable_disk_usage();

  // @@protoc_insertion_point(class_scope:zurg.SlaveHeartbeat)
 private:
  inline void set_has_slave_name();
  inline void clear_has_slave_name();
  inline void set_has_send_time_us();
  inline void clear_has_send_time_us();
  inline void set_has_host_name();
  inline void clear_has_host_name();
  inline void set_has_listen_port();
  inline void clear_has_listen_port();
  inline void set_has_slave_pid();
  inline void clear_has_slave_pid();
  inline void set_has_start_time_us();
  inline void clear_has_start_time_us();
  inline void set_has_slave_version();
  inline void clear_has_slave_version();
  inline void set_has_cpuinfo();
  inline void clear_has_cpuinfo();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_etc_mtab();
  inline void clear_has_etc_mtab();
  inline void set_has_sysctl();
  inline void clear_has_sysctl();
  inline void set_has_uname();
  inline void clear_has_uname();
  inline void set_has_meminfo();
  inline void clear_has_meminfo();
  inline void set_has_proc_stat();
  inline void clear_has_proc_stat();
  inline void set_has_loadavg();
  inline void clear_has_loadavg();
  inline void set_has_diskstats();
  inline void clear_has_diskstats();
  inline void set_has_net_dev();
  inline void clear_has_net_dev();
  inline void set_has_net_tcp();
  inline void clear_has_net_tcp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* slave_name_;
  ::google::protobuf::int64 send_time_us_;
  ::std::string* host_name_;
  ::google::protobuf::int32 listen_port_;
  ::google::protobuf::int32 slave_pid_;
  ::google::protobuf::int64 start_time_us_;
  ::std::string* slave_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> env_vars_;
  ::std::string* cpuinfo_;
  ::std::string* version_;
  ::std::string* etc_mtab_;
  ::std::string* sysctl_;
  ::zurg::SlaveHeartbeat_Uname* uname_;
  ::std::string* meminfo_;
  ::std::string* proc_stat_;
  ::std::string* loadavg_;
  ::std::string* diskstats_;
  ::std::string* net_dev_;
  ::std::string* net_tcp_;
  ::google::protobuf::RepeatedPtrField< ::zurg::DiskUsage > disk_usage_;
  friend void  protobuf_AddDesc_master_2eproto();
  friend void protobuf_AssignDesc_master_2eproto();
  friend void protobuf_ShutdownFile_master_2eproto();

  void InitAsDefaultInstance();
  static SlaveHeartbeat* default_instance_;
};
// ===================================================================


// ===================================================================

// SlaveHeartbeat_Uname

// required string sysname = 1;
inline bool SlaveHeartbeat_Uname::has_sysname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_sysname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveHeartbeat_Uname::clear_has_sysname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveHeartbeat_Uname::clear_sysname() {
  if (sysname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysname_->clear();
  }
  clear_has_sysname();
}
inline const ::std::string& SlaveHeartbeat_Uname::sysname() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.Uname.sysname)
  return *sysname_;
}
inline void SlaveHeartbeat_Uname::set_sysname(const ::std::string& value) {
  set_has_sysname();
  if (sysname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysname_ = new ::std::string;
  }
  sysname_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.Uname.sysname)
}
inline void SlaveHeartbeat_Uname::set_sysname(const char* value) {
  set_has_sysname();
  if (sysname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysname_ = new ::std::string;
  }
  sysname_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.Uname.sysname)
}
inline void SlaveHeartbeat_Uname::set_sysname(const char* value, size_t size) {
  set_has_sysname();
  if (sysname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysname_ = new ::std::string;
  }
  sysname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.Uname.sysname)
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_sysname() {
  set_has_sysname();
  if (sysname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.Uname.sysname)
  return sysname_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_sysname() {
  clear_has_sysname();
  if (sysname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sysname_;
    sysname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat_Uname::set_allocated_sysname(::std::string* sysname) {
  if (sysname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sysname_;
  }
  if (sysname) {
    set_has_sysname();
    sysname_ = sysname;
  } else {
    clear_has_sysname();
    sysname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.Uname.sysname)
}

// required string nodename = 2;
inline bool SlaveHeartbeat_Uname::has_nodename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_nodename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveHeartbeat_Uname::clear_has_nodename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveHeartbeat_Uname::clear_nodename() {
  if (nodename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_->clear();
  }
  clear_has_nodename();
}
inline const ::std::string& SlaveHeartbeat_Uname::nodename() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.Uname.nodename)
  return *nodename_;
}
inline void SlaveHeartbeat_Uname::set_nodename(const ::std::string& value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.Uname.nodename)
}
inline void SlaveHeartbeat_Uname::set_nodename(const char* value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.Uname.nodename)
}
inline void SlaveHeartbeat_Uname::set_nodename(const char* value, size_t size) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.Uname.nodename)
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_nodename() {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.Uname.nodename)
  return nodename_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_nodename() {
  clear_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nodename_;
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat_Uname::set_allocated_nodename(::std::string* nodename) {
  if (nodename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nodename_;
  }
  if (nodename) {
    set_has_nodename();
    nodename_ = nodename;
  } else {
    clear_has_nodename();
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.Uname.nodename)
}

// required string release = 3;
inline bool SlaveHeartbeat_Uname::has_release() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_release() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveHeartbeat_Uname::clear_has_release() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveHeartbeat_Uname::clear_release() {
  if (release_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_->clear();
  }
  clear_has_release();
}
inline const ::std::string& SlaveHeartbeat_Uname::release() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.Uname.release)
  return *release_;
}
inline void SlaveHeartbeat_Uname::set_release(const ::std::string& value) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  release_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.Uname.release)
}
inline void SlaveHeartbeat_Uname::set_release(const char* value) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  release_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.Uname.release)
}
inline void SlaveHeartbeat_Uname::set_release(const char* value, size_t size) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  release_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.Uname.release)
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_release() {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.Uname.release)
  return release_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_release() {
  clear_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = release_;
    release_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat_Uname::set_allocated_release(::std::string* release) {
  if (release_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete release_;
  }
  if (release) {
    set_has_release();
    release_ = release;
  } else {
    clear_has_release();
    release_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.Uname.release)
}

// required string version = 4;
inline bool SlaveHeartbeat_Uname::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveHeartbeat_Uname::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveHeartbeat_Uname::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& SlaveHeartbeat_Uname::version() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.Uname.version)
  return *version_;
}
inline void SlaveHeartbeat_Uname::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.Uname.version)
}
inline void SlaveHeartbeat_Uname::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.Uname.version)
}
inline void SlaveHeartbeat_Uname::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.Uname.version)
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.Uname.version)
  return version_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat_Uname::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.Uname.version)
}

// required string machine = 5;
inline bool SlaveHeartbeat_Uname::has_machine() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_machine() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveHeartbeat_Uname::clear_has_machine() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveHeartbeat_Uname::clear_machine() {
  if (machine_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machine_->clear();
  }
  clear_has_machine();
}
inline const ::std::string& SlaveHeartbeat_Uname::machine() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.Uname.machine)
  return *machine_;
}
inline void SlaveHeartbeat_Uname::set_machine(const ::std::string& value) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machine_ = new ::std::string;
  }
  machine_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.Uname.machine)
}
inline void SlaveHeartbeat_Uname::set_machine(const char* value) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machine_ = new ::std::string;
  }
  machine_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.Uname.machine)
}
inline void SlaveHeartbeat_Uname::set_machine(const char* value, size_t size) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machine_ = new ::std::string;
  }
  machine_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.Uname.machine)
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_machine() {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machine_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.Uname.machine)
  return machine_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_machine() {
  clear_has_machine();
  if (machine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = machine_;
    machine_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat_Uname::set_allocated_machine(::std::string* machine) {
  if (machine_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete machine_;
  }
  if (machine) {
    set_has_machine();
    machine_ = machine;
  } else {
    clear_has_machine();
    machine_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.Uname.machine)
}

// required string domainname = 6;
inline bool SlaveHeartbeat_Uname::has_domainname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveHeartbeat_Uname::set_has_domainname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveHeartbeat_Uname::clear_has_domainname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveHeartbeat_Uname::clear_domainname() {
  if (domainname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domainname_->clear();
  }
  clear_has_domainname();
}
inline const ::std::string& SlaveHeartbeat_Uname::domainname() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.Uname.domainname)
  return *domainname_;
}
inline void SlaveHeartbeat_Uname::set_domainname(const ::std::string& value) {
  set_has_domainname();
  if (domainname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domainname_ = new ::std::string;
  }
  domainname_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.Uname.domainname)
}
inline void SlaveHeartbeat_Uname::set_domainname(const char* value) {
  set_has_domainname();
  if (domainname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domainname_ = new ::std::string;
  }
  domainname_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.Uname.domainname)
}
inline void SlaveHeartbeat_Uname::set_domainname(const char* value, size_t size) {
  set_has_domainname();
  if (domainname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domainname_ = new ::std::string;
  }
  domainname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.Uname.domainname)
}
inline ::std::string* SlaveHeartbeat_Uname::mutable_domainname() {
  set_has_domainname();
  if (domainname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domainname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.Uname.domainname)
  return domainname_;
}
inline ::std::string* SlaveHeartbeat_Uname::release_domainname() {
  clear_has_domainname();
  if (domainname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = domainname_;
    domainname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat_Uname::set_allocated_domainname(::std::string* domainname) {
  if (domainname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete domainname_;
  }
  if (domainname) {
    set_has_domainname();
    domainname_ = domainname;
  } else {
    clear_has_domainname();
    domainname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.Uname.domainname)
}

// -------------------------------------------------------------------

// SlaveHeartbeat

// required string slave_name = 1;
inline bool SlaveHeartbeat::has_slave_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveHeartbeat::set_has_slave_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveHeartbeat::clear_has_slave_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveHeartbeat::clear_slave_name() {
  if (slave_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_name_->clear();
  }
  clear_has_slave_name();
}
inline const ::std::string& SlaveHeartbeat::slave_name() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.slave_name)
  return *slave_name_;
}
inline void SlaveHeartbeat::set_slave_name(const ::std::string& value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.slave_name)
}
inline void SlaveHeartbeat::set_slave_name(const char* value) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.slave_name)
}
inline void SlaveHeartbeat::set_slave_name(const char* value, size_t size) {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_name_ = new ::std::string;
  }
  slave_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.slave_name)
}
inline ::std::string* SlaveHeartbeat::mutable_slave_name() {
  set_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.slave_name)
  return slave_name_;
}
inline ::std::string* SlaveHeartbeat::release_slave_name() {
  clear_has_slave_name();
  if (slave_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = slave_name_;
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_slave_name(::std::string* slave_name) {
  if (slave_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete slave_name_;
  }
  if (slave_name) {
    set_has_slave_name();
    slave_name_ = slave_name;
  } else {
    clear_has_slave_name();
    slave_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.slave_name)
}

// required int64 send_time_us = 2;
inline bool SlaveHeartbeat::has_send_time_us() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveHeartbeat::set_has_send_time_us() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveHeartbeat::clear_has_send_time_us() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveHeartbeat::clear_send_time_us() {
  send_time_us_ = GOOGLE_LONGLONG(0);
  clear_has_send_time_us();
}
inline ::google::protobuf::int64 SlaveHeartbeat::send_time_us() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.send_time_us)
  return send_time_us_;
}
inline void SlaveHeartbeat::set_send_time_us(::google::protobuf::int64 value) {
  set_has_send_time_us();
  send_time_us_ = value;
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.send_time_us)
}

// optional string host_name = 20;
inline bool SlaveHeartbeat::has_host_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveHeartbeat::set_has_host_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveHeartbeat::clear_has_host_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveHeartbeat::clear_host_name() {
  if (host_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_->clear();
  }
  clear_has_host_name();
}
inline const ::std::string& SlaveHeartbeat::host_name() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.host_name)
  return *host_name_;
}
inline void SlaveHeartbeat::set_host_name(const ::std::string& value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.host_name)
}
inline void SlaveHeartbeat::set_host_name(const char* value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.host_name)
}
inline void SlaveHeartbeat::set_host_name(const char* value, size_t size) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.host_name)
}
inline ::std::string* SlaveHeartbeat::mutable_host_name() {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.host_name)
  return host_name_;
}
inline ::std::string* SlaveHeartbeat::release_host_name() {
  clear_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = host_name_;
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_host_name(::std::string* host_name) {
  if (host_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_name_;
  }
  if (host_name) {
    set_has_host_name();
    host_name_ = host_name;
  } else {
    clear_has_host_name();
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.host_name)
}

// optional int32 listen_port = 21;
inline bool SlaveHeartbeat::has_listen_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveHeartbeat::set_has_listen_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveHeartbeat::clear_has_listen_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveHeartbeat::clear_listen_port() {
  listen_port_ = 0;
  clear_has_listen_port();
}
inline ::google::protobuf::int32 SlaveHeartbeat::listen_port() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.listen_port)
  return listen_port_;
}
inline void SlaveHeartbeat::set_listen_port(::google::protobuf::int32 value) {
  set_has_listen_port();
  listen_port_ = value;
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.listen_port)
}

// optional int32 slave_pid = 22;
inline bool SlaveHeartbeat::has_slave_pid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveHeartbeat::set_has_slave_pid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveHeartbeat::clear_has_slave_pid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveHeartbeat::clear_slave_pid() {
  slave_pid_ = 0;
  clear_has_slave_pid();
}
inline ::google::protobuf::int32 SlaveHeartbeat::slave_pid() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.slave_pid)
  return slave_pid_;
}
inline void SlaveHeartbeat::set_slave_pid(::google::protobuf::int32 value) {
  set_has_slave_pid();
  slave_pid_ = value;
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.slave_pid)
}

// optional int64 start_time_us = 23;
inline bool SlaveHeartbeat::has_start_time_us() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveHeartbeat::set_has_start_time_us() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveHeartbeat::clear_has_start_time_us() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveHeartbeat::clear_start_time_us() {
  start_time_us_ = GOOGLE_LONGLONG(0);
  clear_has_start_time_us();
}
inline ::google::protobuf::int64 SlaveHeartbeat::start_time_us() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.start_time_us)
  return start_time_us_;
}
inline void SlaveHeartbeat::set_start_time_us(::google::protobuf::int64 value) {
  set_has_start_time_us();
  start_time_us_ = value;
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.start_time_us)
}

// optional string slave_version = 24;
inline bool SlaveHeartbeat::has_slave_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SlaveHeartbeat::set_has_slave_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SlaveHeartbeat::clear_has_slave_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SlaveHeartbeat::clear_slave_version() {
  if (slave_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_version_->clear();
  }
  clear_has_slave_version();
}
inline const ::std::string& SlaveHeartbeat::slave_version() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.slave_version)
  return *slave_version_;
}
inline void SlaveHeartbeat::set_slave_version(const ::std::string& value) {
  set_has_slave_version();
  if (slave_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_version_ = new ::std::string;
  }
  slave_version_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.slave_version)
}
inline void SlaveHeartbeat::set_slave_version(const char* value) {
  set_has_slave_version();
  if (slave_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_version_ = new ::std::string;
  }
  slave_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.slave_version)
}
inline void SlaveHeartbeat::set_slave_version(const char* value, size_t size) {
  set_has_slave_version();
  if (slave_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_version_ = new ::std::string;
  }
  slave_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.slave_version)
}
inline ::std::string* SlaveHeartbeat::mutable_slave_version() {
  set_has_slave_version();
  if (slave_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.slave_version)
  return slave_version_;
}
inline ::std::string* SlaveHeartbeat::release_slave_version() {
  clear_has_slave_version();
  if (slave_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = slave_version_;
    slave_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_slave_version(::std::string* slave_version) {
  if (slave_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete slave_version_;
  }
  if (slave_version) {
    set_has_slave_version();
    slave_version_ = slave_version;
  } else {
    clear_has_slave_version();
    slave_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.slave_version)
}

// repeated string env_vars = 25;
inline int SlaveHeartbeat::env_vars_size() const {
  return env_vars_.size();
}
inline void SlaveHeartbeat::clear_env_vars() {
  env_vars_.Clear();
}
inline const ::std::string& SlaveHeartbeat::env_vars(int index) const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.env_vars)
  return env_vars_.Get(index);
}
inline ::std::string* SlaveHeartbeat::mutable_env_vars(int index) {
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.env_vars)
  return env_vars_.Mutable(index);
}
inline void SlaveHeartbeat::set_env_vars(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.env_vars)
  env_vars_.Mutable(index)->assign(value);
}
inline void SlaveHeartbeat::set_env_vars(int index, const char* value) {
  env_vars_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.env_vars)
}
inline void SlaveHeartbeat::set_env_vars(int index, const char* value, size_t size) {
  env_vars_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.env_vars)
}
inline ::std::string* SlaveHeartbeat::add_env_vars() {
  return env_vars_.Add();
}
inline void SlaveHeartbeat::add_env_vars(const ::std::string& value) {
  env_vars_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zurg.SlaveHeartbeat.env_vars)
}
inline void SlaveHeartbeat::add_env_vars(const char* value) {
  env_vars_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zurg.SlaveHeartbeat.env_vars)
}
inline void SlaveHeartbeat::add_env_vars(const char* value, size_t size) {
  env_vars_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zurg.SlaveHeartbeat.env_vars)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SlaveHeartbeat::env_vars() const {
  // @@protoc_insertion_point(field_list:zurg.SlaveHeartbeat.env_vars)
  return env_vars_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SlaveHeartbeat::mutable_env_vars() {
  // @@protoc_insertion_point(field_mutable_list:zurg.SlaveHeartbeat.env_vars)
  return &env_vars_;
}

// optional string cpuinfo = 30;
inline bool SlaveHeartbeat::has_cpuinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SlaveHeartbeat::set_has_cpuinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SlaveHeartbeat::clear_has_cpuinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SlaveHeartbeat::clear_cpuinfo() {
  if (cpuinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cpuinfo_->clear();
  }
  clear_has_cpuinfo();
}
inline const ::std::string& SlaveHeartbeat::cpuinfo() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.cpuinfo)
  return *cpuinfo_;
}
inline void SlaveHeartbeat::set_cpuinfo(const ::std::string& value) {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cpuinfo_ = new ::std::string;
  }
  cpuinfo_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.cpuinfo)
}
inline void SlaveHeartbeat::set_cpuinfo(const char* value) {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cpuinfo_ = new ::std::string;
  }
  cpuinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.cpuinfo)
}
inline void SlaveHeartbeat::set_cpuinfo(const char* value, size_t size) {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cpuinfo_ = new ::std::string;
  }
  cpuinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.cpuinfo)
}
inline ::std::string* SlaveHeartbeat::mutable_cpuinfo() {
  set_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cpuinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.cpuinfo)
  return cpuinfo_;
}
inline ::std::string* SlaveHeartbeat::release_cpuinfo() {
  clear_has_cpuinfo();
  if (cpuinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cpuinfo_;
    cpuinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_cpuinfo(::std::string* cpuinfo) {
  if (cpuinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cpuinfo_;
  }
  if (cpuinfo) {
    set_has_cpuinfo();
    cpuinfo_ = cpuinfo;
  } else {
    clear_has_cpuinfo();
    cpuinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.cpuinfo)
}

// optional string version = 31;
inline bool SlaveHeartbeat::has_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SlaveHeartbeat::set_has_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SlaveHeartbeat::clear_has_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SlaveHeartbeat::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& SlaveHeartbeat::version() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.version)
  return *version_;
}
inline void SlaveHeartbeat::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.version)
}
inline void SlaveHeartbeat::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.version)
}
inline void SlaveHeartbeat::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.version)
}
inline ::std::string* SlaveHeartbeat::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.version)
  return version_;
}
inline ::std::string* SlaveHeartbeat::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.version)
}

// optional string etc_mtab = 32;
inline bool SlaveHeartbeat::has_etc_mtab() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SlaveHeartbeat::set_has_etc_mtab() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SlaveHeartbeat::clear_has_etc_mtab() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SlaveHeartbeat::clear_etc_mtab() {
  if (etc_mtab_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    etc_mtab_->clear();
  }
  clear_has_etc_mtab();
}
inline const ::std::string& SlaveHeartbeat::etc_mtab() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.etc_mtab)
  return *etc_mtab_;
}
inline void SlaveHeartbeat::set_etc_mtab(const ::std::string& value) {
  set_has_etc_mtab();
  if (etc_mtab_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    etc_mtab_ = new ::std::string;
  }
  etc_mtab_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.etc_mtab)
}
inline void SlaveHeartbeat::set_etc_mtab(const char* value) {
  set_has_etc_mtab();
  if (etc_mtab_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    etc_mtab_ = new ::std::string;
  }
  etc_mtab_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.etc_mtab)
}
inline void SlaveHeartbeat::set_etc_mtab(const char* value, size_t size) {
  set_has_etc_mtab();
  if (etc_mtab_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    etc_mtab_ = new ::std::string;
  }
  etc_mtab_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.etc_mtab)
}
inline ::std::string* SlaveHeartbeat::mutable_etc_mtab() {
  set_has_etc_mtab();
  if (etc_mtab_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    etc_mtab_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.etc_mtab)
  return etc_mtab_;
}
inline ::std::string* SlaveHeartbeat::release_etc_mtab() {
  clear_has_etc_mtab();
  if (etc_mtab_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = etc_mtab_;
    etc_mtab_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_etc_mtab(::std::string* etc_mtab) {
  if (etc_mtab_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete etc_mtab_;
  }
  if (etc_mtab) {
    set_has_etc_mtab();
    etc_mtab_ = etc_mtab;
  } else {
    clear_has_etc_mtab();
    etc_mtab_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.etc_mtab)
}

// optional string sysctl = 33;
inline bool SlaveHeartbeat::has_sysctl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SlaveHeartbeat::set_has_sysctl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SlaveHeartbeat::clear_has_sysctl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SlaveHeartbeat::clear_sysctl() {
  if (sysctl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysctl_->clear();
  }
  clear_has_sysctl();
}
inline const ::std::string& SlaveHeartbeat::sysctl() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.sysctl)
  return *sysctl_;
}
inline void SlaveHeartbeat::set_sysctl(const ::std::string& value) {
  set_has_sysctl();
  if (sysctl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysctl_ = new ::std::string;
  }
  sysctl_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.sysctl)
}
inline void SlaveHeartbeat::set_sysctl(const char* value) {
  set_has_sysctl();
  if (sysctl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysctl_ = new ::std::string;
  }
  sysctl_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.sysctl)
}
inline void SlaveHeartbeat::set_sysctl(const char* value, size_t size) {
  set_has_sysctl();
  if (sysctl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysctl_ = new ::std::string;
  }
  sysctl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.sysctl)
}
inline ::std::string* SlaveHeartbeat::mutable_sysctl() {
  set_has_sysctl();
  if (sysctl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysctl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.sysctl)
  return sysctl_;
}
inline ::std::string* SlaveHeartbeat::release_sysctl() {
  clear_has_sysctl();
  if (sysctl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sysctl_;
    sysctl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_sysctl(::std::string* sysctl) {
  if (sysctl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sysctl_;
  }
  if (sysctl) {
    set_has_sysctl();
    sysctl_ = sysctl;
  } else {
    clear_has_sysctl();
    sysctl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.sysctl)
}

// optional .zurg.SlaveHeartbeat.Uname uname = 34;
inline bool SlaveHeartbeat::has_uname() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SlaveHeartbeat::set_has_uname() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SlaveHeartbeat::clear_has_uname() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SlaveHeartbeat::clear_uname() {
  if (uname_ != NULL) uname_->::zurg::SlaveHeartbeat_Uname::Clear();
  clear_has_uname();
}
inline const ::zurg::SlaveHeartbeat_Uname& SlaveHeartbeat::uname() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.uname)
  return uname_ != NULL ? *uname_ : *default_instance_->uname_;
}
inline ::zurg::SlaveHeartbeat_Uname* SlaveHeartbeat::mutable_uname() {
  set_has_uname();
  if (uname_ == NULL) uname_ = new ::zurg::SlaveHeartbeat_Uname;
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.uname)
  return uname_;
}
inline ::zurg::SlaveHeartbeat_Uname* SlaveHeartbeat::release_uname() {
  clear_has_uname();
  ::zurg::SlaveHeartbeat_Uname* temp = uname_;
  uname_ = NULL;
  return temp;
}
inline void SlaveHeartbeat::set_allocated_uname(::zurg::SlaveHeartbeat_Uname* uname) {
  delete uname_;
  uname_ = uname;
  if (uname) {
    set_has_uname();
  } else {
    clear_has_uname();
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.uname)
}

// optional string meminfo = 40;
inline bool SlaveHeartbeat::has_meminfo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SlaveHeartbeat::set_has_meminfo() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SlaveHeartbeat::clear_has_meminfo() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SlaveHeartbeat::clear_meminfo() {
  if (meminfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    meminfo_->clear();
  }
  clear_has_meminfo();
}
inline const ::std::string& SlaveHeartbeat::meminfo() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.meminfo)
  return *meminfo_;
}
inline void SlaveHeartbeat::set_meminfo(const ::std::string& value) {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    meminfo_ = new ::std::string;
  }
  meminfo_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.meminfo)
}
inline void SlaveHeartbeat::set_meminfo(const char* value) {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    meminfo_ = new ::std::string;
  }
  meminfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.meminfo)
}
inline void SlaveHeartbeat::set_meminfo(const char* value, size_t size) {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    meminfo_ = new ::std::string;
  }
  meminfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.meminfo)
}
inline ::std::string* SlaveHeartbeat::mutable_meminfo() {
  set_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    meminfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.meminfo)
  return meminfo_;
}
inline ::std::string* SlaveHeartbeat::release_meminfo() {
  clear_has_meminfo();
  if (meminfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = meminfo_;
    meminfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_meminfo(::std::string* meminfo) {
  if (meminfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete meminfo_;
  }
  if (meminfo) {
    set_has_meminfo();
    meminfo_ = meminfo;
  } else {
    clear_has_meminfo();
    meminfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.meminfo)
}

// optional string proc_stat = 41;
inline bool SlaveHeartbeat::has_proc_stat() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SlaveHeartbeat::set_has_proc_stat() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SlaveHeartbeat::clear_has_proc_stat() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SlaveHeartbeat::clear_proc_stat() {
  if (proc_stat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proc_stat_->clear();
  }
  clear_has_proc_stat();
}
inline const ::std::string& SlaveHeartbeat::proc_stat() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.proc_stat)
  return *proc_stat_;
}
inline void SlaveHeartbeat::set_proc_stat(const ::std::string& value) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.proc_stat)
}
inline void SlaveHeartbeat::set_proc_stat(const char* value) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.proc_stat)
}
inline void SlaveHeartbeat::set_proc_stat(const char* value, size_t size) {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proc_stat_ = new ::std::string;
  }
  proc_stat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.proc_stat)
}
inline ::std::string* SlaveHeartbeat::mutable_proc_stat() {
  set_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    proc_stat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.proc_stat)
  return proc_stat_;
}
inline ::std::string* SlaveHeartbeat::release_proc_stat() {
  clear_has_proc_stat();
  if (proc_stat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = proc_stat_;
    proc_stat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_proc_stat(::std::string* proc_stat) {
  if (proc_stat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete proc_stat_;
  }
  if (proc_stat) {
    set_has_proc_stat();
    proc_stat_ = proc_stat;
  } else {
    clear_has_proc_stat();
    proc_stat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.proc_stat)
}

// optional string loadavg = 42;
inline bool SlaveHeartbeat::has_loadavg() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SlaveHeartbeat::set_has_loadavg() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SlaveHeartbeat::clear_has_loadavg() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SlaveHeartbeat::clear_loadavg() {
  if (loadavg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loadavg_->clear();
  }
  clear_has_loadavg();
}
inline const ::std::string& SlaveHeartbeat::loadavg() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.loadavg)
  return *loadavg_;
}
inline void SlaveHeartbeat::set_loadavg(const ::std::string& value) {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loadavg_ = new ::std::string;
  }
  loadavg_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.loadavg)
}
inline void SlaveHeartbeat::set_loadavg(const char* value) {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loadavg_ = new ::std::string;
  }
  loadavg_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.loadavg)
}
inline void SlaveHeartbeat::set_loadavg(const char* value, size_t size) {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loadavg_ = new ::std::string;
  }
  loadavg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.loadavg)
}
inline ::std::string* SlaveHeartbeat::mutable_loadavg() {
  set_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    loadavg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.loadavg)
  return loadavg_;
}
inline ::std::string* SlaveHeartbeat::release_loadavg() {
  clear_has_loadavg();
  if (loadavg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = loadavg_;
    loadavg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_loadavg(::std::string* loadavg) {
  if (loadavg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete loadavg_;
  }
  if (loadavg) {
    set_has_loadavg();
    loadavg_ = loadavg;
  } else {
    clear_has_loadavg();
    loadavg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.loadavg)
}

// optional string diskstats = 43;
inline bool SlaveHeartbeat::has_diskstats() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SlaveHeartbeat::set_has_diskstats() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SlaveHeartbeat::clear_has_diskstats() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SlaveHeartbeat::clear_diskstats() {
  if (diskstats_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diskstats_->clear();
  }
  clear_has_diskstats();
}
inline const ::std::string& SlaveHeartbeat::diskstats() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.diskstats)
  return *diskstats_;
}
inline void SlaveHeartbeat::set_diskstats(const ::std::string& value) {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diskstats_ = new ::std::string;
  }
  diskstats_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.diskstats)
}
inline void SlaveHeartbeat::set_diskstats(const char* value) {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diskstats_ = new ::std::string;
  }
  diskstats_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.diskstats)
}
inline void SlaveHeartbeat::set_diskstats(const char* value, size_t size) {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diskstats_ = new ::std::string;
  }
  diskstats_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.diskstats)
}
inline ::std::string* SlaveHeartbeat::mutable_diskstats() {
  set_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diskstats_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.diskstats)
  return diskstats_;
}
inline ::std::string* SlaveHeartbeat::release_diskstats() {
  clear_has_diskstats();
  if (diskstats_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diskstats_;
    diskstats_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_diskstats(::std::string* diskstats) {
  if (diskstats_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diskstats_;
  }
  if (diskstats) {
    set_has_diskstats();
    diskstats_ = diskstats;
  } else {
    clear_has_diskstats();
    diskstats_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.diskstats)
}

// optional string net_dev = 44;
inline bool SlaveHeartbeat::has_net_dev() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SlaveHeartbeat::set_has_net_dev() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SlaveHeartbeat::clear_has_net_dev() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SlaveHeartbeat::clear_net_dev() {
  if (net_dev_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_dev_->clear();
  }
  clear_has_net_dev();
}
inline const ::std::string& SlaveHeartbeat::net_dev() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.net_dev)
  return *net_dev_;
}
inline void SlaveHeartbeat::set_net_dev(const ::std::string& value) {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_dev_ = new ::std::string;
  }
  net_dev_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.net_dev)
}
inline void SlaveHeartbeat::set_net_dev(const char* value) {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_dev_ = new ::std::string;
  }
  net_dev_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.net_dev)
}
inline void SlaveHeartbeat::set_net_dev(const char* value, size_t size) {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_dev_ = new ::std::string;
  }
  net_dev_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.net_dev)
}
inline ::std::string* SlaveHeartbeat::mutable_net_dev() {
  set_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_dev_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.net_dev)
  return net_dev_;
}
inline ::std::string* SlaveHeartbeat::release_net_dev() {
  clear_has_net_dev();
  if (net_dev_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = net_dev_;
    net_dev_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_net_dev(::std::string* net_dev) {
  if (net_dev_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete net_dev_;
  }
  if (net_dev) {
    set_has_net_dev();
    net_dev_ = net_dev;
  } else {
    clear_has_net_dev();
    net_dev_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.net_dev)
}

// optional string net_tcp = 45;
inline bool SlaveHeartbeat::has_net_tcp() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SlaveHeartbeat::set_has_net_tcp() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SlaveHeartbeat::clear_has_net_tcp() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SlaveHeartbeat::clear_net_tcp() {
  if (net_tcp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_tcp_->clear();
  }
  clear_has_net_tcp();
}
inline const ::std::string& SlaveHeartbeat::net_tcp() const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.net_tcp)
  return *net_tcp_;
}
inline void SlaveHeartbeat::set_net_tcp(const ::std::string& value) {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_tcp_ = new ::std::string;
  }
  net_tcp_->assign(value);
  // @@protoc_insertion_point(field_set:zurg.SlaveHeartbeat.net_tcp)
}
inline void SlaveHeartbeat::set_net_tcp(const char* value) {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_tcp_ = new ::std::string;
  }
  net_tcp_->assign(value);
  // @@protoc_insertion_point(field_set_char:zurg.SlaveHeartbeat.net_tcp)
}
inline void SlaveHeartbeat::set_net_tcp(const char* value, size_t size) {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_tcp_ = new ::std::string;
  }
  net_tcp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zurg.SlaveHeartbeat.net_tcp)
}
inline ::std::string* SlaveHeartbeat::mutable_net_tcp() {
  set_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_tcp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.net_tcp)
  return net_tcp_;
}
inline ::std::string* SlaveHeartbeat::release_net_tcp() {
  clear_has_net_tcp();
  if (net_tcp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = net_tcp_;
    net_tcp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SlaveHeartbeat::set_allocated_net_tcp(::std::string* net_tcp) {
  if (net_tcp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete net_tcp_;
  }
  if (net_tcp) {
    set_has_net_tcp();
    net_tcp_ = net_tcp;
  } else {
    clear_has_net_tcp();
    net_tcp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zurg.SlaveHeartbeat.net_tcp)
}

// repeated .zurg.DiskUsage disk_usage = 50;
inline int SlaveHeartbeat::disk_usage_size() const {
  return disk_usage_.size();
}
inline void SlaveHeartbeat::clear_disk_usage() {
  disk_usage_.Clear();
}
inline const ::zurg::DiskUsage& SlaveHeartbeat::disk_usage(int index) const {
  // @@protoc_insertion_point(field_get:zurg.SlaveHeartbeat.disk_usage)
  return disk_usage_.Get(index);
}
inline ::zurg::DiskUsage* SlaveHeartbeat::mutable_disk_usage(int index) {
  // @@protoc_insertion_point(field_mutable:zurg.SlaveHeartbeat.disk_usage)
  return disk_usage_.Mutable(index);
}
inline ::zurg::DiskUsage* SlaveHeartbeat::add_disk_usage() {
  // @@protoc_insertion_point(field_add:zurg.SlaveHeartbeat.disk_usage)
  return disk_usage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zurg::DiskUsage >&
SlaveHeartbeat::disk_usage() const {
  // @@protoc_insertion_point(field_list:zurg.SlaveHeartbeat.disk_usage)
  return disk_usage_;
}
inline ::google::protobuf::RepeatedPtrField< ::zurg::DiskUsage >*
SlaveHeartbeat::mutable_disk_usage() {
  // @@protoc_insertion_point(field_mutable_list:zurg.SlaveHeartbeat.disk_usage)
  return &disk_usage_;
}



// ===================================================================

typedef ::std::shared_ptr<SlaveHeartbeat> SlaveHeartbeatPtr;

// -------------------------------------------------------------------

class MasterService_Stub;

class MasterService : public ::muduo::net::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline MasterService() {};
 public:
  virtual ~MasterService();

  typedef MasterService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void slaveHeartbeat(const ::zurg::SlaveHeartbeatPtr& request,
                       const ::rpc2::Empty* responsePrototype,
                       const ::muduo::net::RpcDoneCallback& done);
  virtual void appStatusChange(const ::zurg::ApplicationStatusPtr& request,
                       const ::rpc2::Empty* responsePrototype,
                       const ::muduo::net::RpcDoneCallback& done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  const ::google::protobuf::MessagePtr& request,
                  const ::google::protobuf::Message* responsePrototype,
                  const ::muduo::net::RpcDoneCallback& done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MasterService);
};

class MasterService_Stub : public MasterService {
 public:
  MasterService_Stub(::muduo::net::RpcChannel* channel);
  ~MasterService_Stub();

  inline ::muduo::net::RpcChannel* channel() { return channel_; }

  // implements MasterService ------------------------------------------

  using MasterService::slaveHeartbeat;
  virtual void slaveHeartbeat(const ::zurg::SlaveHeartbeat& request,
                       const ::std::function<void(const ::rpc2::EmptyPtr&)>& done);
  using MasterService::appStatusChange;
  virtual void appStatusChange(const ::zurg::ApplicationStatus& request,
                       const ::std::function<void(const ::rpc2::EmptyPtr&)>& done);
 private:
  ::muduo::net::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MasterService_Stub);
};

// @@protoc_insertion_point(namespace_scope)

}  // namespace zurg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_master_2eproto__INCLUDED
